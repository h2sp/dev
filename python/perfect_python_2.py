#-- coding:utf-8 --#

def docstring_test():
    """この関数はドックストリングのテストです"""
    return True

## 2-5 識別子
"""
_(アンダースコア)で始まる識別子は、モジュールからワイルドカードでインポートをした場合に
インポートされない
インタラクティブでは直前の結果を「_」
"""

## 2-6 変数
"""
pythonの変数は識別子であればよい
"""

### 2-6-1 グローバル変数
"""
グローバル変数は、プログラム全体から使える変数をいうが、
厳密にはpythonにはグローバル変数はありません
関数やクラスの中でglobalというキーワードを用いると、
グローバル変数を用いるという指定になります

global宣言をせずに関数の内側のスコープから参照した変数を
操作しようとすると例外が発生する

変数の定義なしに内側のスコープから参照した場合は、
グローバル変数を参照できる
"""

spam = 'ham'

def egg():
    #global spam
    #print(spam)
    #spam = 'egg'
    print(spam)

egg()
#print spam


### 2-6-2 ノンローカル変数
"""
nonlocal キーワードを使うと、ローカルスコープではない
一番近くの変数を利用できます
"""

def counter():
    count = 0
    def _counter():
        nonlocal count
        count += 1
        return count
    return _counter

c = counter()
print(c())
print(c())
print(c())

## 2-9 メモリ管理
"""
pythonのガベージコレクションはリファレンスカウンターを用いたが～ベジコレクタ
pythonは自動的にメモリを開放するので、通常はgcモジュールを使うことはない
お互いに参照しているオブジェクト、いわゆるリファレンスループ（循環参照）の場合、
リファレンスはあるが、そのオブジェクトの組はどこからも参照されておらず、実際は利用されていない
ガーベージコレクタは到達不能なリファレンスループとなっているオブジェクトに関しても
検出して、自動でメモリを解放します
ただし、ファイナライザ(__del__メソッド)が定義されているオブジェクトに関しては、
リファレンスループしている複数のオブジェクトをどの順番で開放するべきか自動で判別できない
自動で解放できないオブジェクトは、gc.garbageにリストで格納される

"""

import gc

class A:
    def __del__(self):
        print('call __del__')

l = [A()]
l[0].l = l
del l

print(gc.collect())
print(gc.garbage)

"""
gcを使って解放する
"""

del gc.garbage[0].l
del gc.garbage[0]
print(gc.collect())

